---
title: "Predicting Presidential Election"
output: rmarkdown::github_document
  # html_document:
  #   df_print: paged
---

# Loading packages
```{r}
library(data.table)
library(ggplot2)
library(scales)
library(gridExtra)
library(choroplethr)
library(forecast)
library(xts)
library(dplyr)
library(ggplot2)
library(ggmap)
library(maps)
library(mapdata)
library(forecast)
```

```{r}
MyPath<-setwd("C:\\Users\\Caio Laptop\\OneDrive - The University of Kansas\\Documents\\PhD\\11. Courses\\19. EECS 731 - Introduction to Data Science\\Final Project")
```

```{r}
colum <- c("enddate","grade","state","population","rawpoll_clinton","rawpoll_trump","samplesize","adjpoll_clinton","adjpoll_trump","type")

poll <- fread("C:\\Users\\Caio Laptop\\OneDrive - The University of Kansas\\Documents\\PhD\\11. Courses\\19. EECS 731 - Introduction to Data Science\\Final Project\\presidential_polls.csv",
              stringsAsFactors = T)
poll$enddate <- as.Date(poll$enddate, "%m/%d/%Y") # Format date
poll$month <- as.Date(cut(poll$enddate,breaks = "month"))
poll <- poll[order(enddate)] # Order by Date
```

```{r}
poll_by_grade <- poll %>% group_by(grade)
```


# Plot of Polls Raw data 
```{r}
ggplot(data = poll, aes(month)) + 
  geom_smooth(aes(y = rawpoll_clinton, color="Clinton"), color="blue") +
  geom_smooth(aes(y = rawpoll_trump, color="Trump"), color="red") +
  scale_x_date(labels = date_format("%Y-%m"),
               date_breaks = "1 month")  + 
  labs(x = "Month", y = "Averaged Poll Results (%)", 
       title = "Presidential Election Poll Results From 12/2015 - 11/2016")
```
(Saving the plot as pdf/png)
```{r}
pdf(paste(MyPath,"/Clinton_Trump_Polls_Raw.pdf", sep=""), width = 10, height = 7)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(data = poll, aes(month)) + 
      geom_smooth(aes(y = rawpoll_clinton, color="Clinton"), color="blue") +
      geom_smooth(aes(y = rawpoll_trump, color="Trump"), color="red") +
      scale_x_date(labels = date_format("%Y-%m"),
                   date_breaks = "1 month")  + 
      labs(x = "Month", y = "Averaged Poll Results (%)", 
           title = "Presidential Election Poll Results From 12/2015 - 11/2016")

png(paste(MyPath,"/Clinton_Trump_Polls_Raw.png", sep=""), width = 800, height = 500)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(data = poll, aes(month)) + 
      geom_smooth(aes(y = rawpoll_clinton, color="Clinton"), color="blue") +
      geom_smooth(aes(y = rawpoll_trump, color="Trump"), color="red") +
      scale_x_date(labels = date_format("%Y-%m"),
                   date_breaks = "1 month")  + 
      labs(x = "Month", y = "Averaged Poll Results (%)", 
           title = "Presidential Election Poll Results From 12/2015 - 11/2016")
```

# Plot of Polls Adjusted data 
```{r}
ggplot(data = poll, aes(month)) + 
  geom_smooth(aes(y = adjpoll_clinton, color = "Clinton"), show.legend = TRUE, color="blue") +
  geom_smooth(aes(y = adjpoll_trump, color = "Trump"), show.legend = TRUE, color="red") +
  scale_x_date(labels = date_format("%Y-%m"),
               date_breaks = "1 month")  + 
  labs(x = "Month", y = "Averaged Poll Results (%)", 
       title = "Presidential Election Poll (Adj) Results From 12/2015 - 11/2016")
```

(Saving the plot as pdf/png)
```{r}
pdf(paste(MyPath,"/Clinton_Trump_Polls_Adj.pdf", sep=""), width = 10, height = 7)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(data = poll, aes(month)) + 
      geom_smooth(aes(y = adjpoll_clinton, color = "Clinton"), show.legend = TRUE, color="blue") +
      geom_smooth(aes(y = adjpoll_trump, color = "Trump"), show.legend = TRUE, color="red") +
      scale_x_date(labels = date_format("%Y-%m"),
                   date_breaks = "1 month")  + 
      labs(x = "Month", y = "Averaged Poll Results (%)", 
           title = "Presidential Election Poll (Adj) Results From 12/2015 - 11/2016")

png(paste(MyPath,"/Clinton_Trump_Polls_Adj.png", sep=""), width = 800, height = 500)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(data = poll, aes(month)) + 
      geom_smooth(aes(y = adjpoll_clinton, color = "Clinton"), show.legend = TRUE, color="blue") +
      geom_smooth(aes(y = adjpoll_trump, color = "Trump"), show.legend = TRUE, color="red") +
      scale_x_date(labels = date_format("%Y-%m"),
                   date_breaks = "1 month")  + 
      labs(x = "Month", y = "Averaged Poll Results (%)", 
           title = "Presidential Election Poll (Adj) Results From 12/2015 - 11/2016")
```

# Plot of Polls Adjusted and Raw data 
```{r}
ggplot(data = poll, aes(month)) + 
  geom_smooth(aes(y = adjpoll_clinton, color = "Clinton"), show.legend = TRUE, color="blue") +
  geom_smooth(aes(y = adjpoll_trump, color = "Trump"), show.legend = TRUE, color="red") +
  geom_smooth(aes(y = rawpoll_clinton, color = "Clinton"), show.legend = TRUE, color="darkblue") +
  geom_smooth(aes(y = rawpoll_trump, color = "Trump"), show.legend = TRUE, color="darkred") +
  scale_x_date(labels = date_format("%Y-%m"),
               date_breaks = "1 month")  + 
  labs(x = "Month", y = "Averaged Poll Results (%)", 
       title = "Presidential Election Poll Results From 12/2015 - 11/2016 (Raw - darker - and Adjusted) ")
```
(Saving the plot as pdf/png)
```{r}
pdf(paste(MyPath,"/Clinton_Trump_Polls_2.pdf", sep=""), width = 10, height = 7)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(data = poll, aes(month)) + 
      geom_smooth(aes(y = adjpoll_clinton, color = "Clinton"), show.legend = TRUE, color="blue") +
      geom_smooth(aes(y = adjpoll_trump, color = "Trump"), show.legend = TRUE, color="red") +
      geom_smooth(aes(y = rawpoll_clinton, color = "Clinton"), show.legend = TRUE, color="darkblue") +
      geom_smooth(aes(y = rawpoll_trump, color = "Trump"), show.legend = TRUE, color="darkred") +
      scale_x_date(labels = date_format("%Y-%m"),
                   date_breaks = "1 month")  + 
      labs(x = "Month", y = "Averaged Poll Results (%)", 
           title = "Presidential Election Poll Results From 12/2015 - 11/2016 (Raw (darker) and Adjusted ")

png(paste(MyPath,"/Clinton_Trump_Polls_2.png", sep=""), width = 800, height = 500)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(data = poll, aes(month)) + 
      geom_smooth(aes(y = adjpoll_clinton, color = "Clinton"), show.legend = TRUE, color="blue") +
      geom_smooth(aes(y = adjpoll_trump, color = "Trump"), show.legend = TRUE, color="red") +
      geom_smooth(aes(y = rawpoll_clinton, color = "Clinton"), show.legend = TRUE, color="darkblue") +
      geom_smooth(aes(y = rawpoll_trump, color = "Trump"), show.legend = TRUE, color="darkred") +
      scale_x_date(labels = date_format("%Y-%m"),
                   date_breaks = "1 month")  + 
      labs(x = "Month", y = "Averaged Poll Results (%)", 
           title = "Presidential Election Poll Results From 12/2015 - 11/2016 (Raw (darker) and Adjusted ")  
```


## Poll Results by Grade
```{r}
ggplot(poll,aes(month,group=month,alpha=.3))+
  geom_boxplot(aes(y = adjpoll_clinton), color="blue")+
  geom_boxplot(aes(y = adjpoll_trump), color="red") + 
  scale_x_date(labels = date_format("%Y-%m"),
               date_breaks = "1 month")+
  facet_wrap(~grade)+labs(x = "Month", y = "Averaged Poll Results (%)", 
                          title = "Presidential Election Poll Results From 12/2015 - 11/2016")
```
(Saving the plot as pdf/png)
```{r}
pdf(paste(MyPath,"/Clinton_Trump_Polls_boxplots.pdf", sep=""), width = 20, height = 15)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(poll,aes(month,group=month,alpha=.3))+
      geom_boxplot(aes(y = adjpoll_clinton), color="blue")+
      geom_boxplot(aes(y = adjpoll_trump), color="red") + 
      scale_x_date(labels = date_format("%Y-%m"),
                   date_breaks = "1 month")+
      facet_wrap(~grade)+labs(x = "Month", y = "Averaged Poll Results (%)", 
                              title = "Presidential Election Poll Results From 12/2015 - 11/2016")

png(paste(MyPath,"/Clinton_Trump_Polls_boxplots.png", sep=""), width = 1100, height = 700)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(poll,aes(month,group=month,alpha=.3))+
      geom_boxplot(aes(y = adjpoll_clinton), color="blue")+
      geom_boxplot(aes(y = adjpoll_trump), color="red") + 
      scale_x_date(labels = date_format("%Y-%m"),
                   date_breaks = "1 month")+
      facet_wrap(~grade)+labs(x = "Month", y = "Averaged Poll Results (%)", 
                              title = "Presidential Election Poll Results From 12/2015 - 11/2016")  
```

# Time Series Models

Now, in this section I plan to run some ARIMA models. I want to see if AutoRegressive models and Moving Averages could be used to explain the variation in in the polls.

## Data Wrangling 
First I need to transform my data to time series.

```{r}
xts_poll<-xts(poll, poll$enddate)
Clinton_Polls<-xts(poll$rawpoll_clinton, poll$enddate)
Trump_Polls<-xts(poll$rawpoll_trump, poll$enddate)
Clinton_Trump_Polls<-merge(Clinton_Polls,Trump_Polls)
```


Plotting the polls by day without any smoothing.
```{r}
autoplot(Clinton_Trump_Polls)  +
  ggtitle("Clinton/Trump Polls - Presidential Election Poll Results From 12/2015 - 11/2016") +
  xlab("Time") +
  ylab("Percentage")
```
(Saving the plot as pdf/png)
```{r}
pdf(paste(MyPath,"/Clinton_Trump_Polls_TS.pdf", sep=""), width = 10, height = 7)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    autoplot(Clinton_Trump_Polls)  +
    ggtitle("Clinton/Trump Polls - Presidential Election Poll Results From 12/2015 - 11/2016") +
      xlab("Time") +
      ylab("Percentage")

png(paste(MyPath,"/Clinton_Trump_Polls_TS.png", sep=""), width = 800, height = 500)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    autoplot(Clinton_Trump_Polls)  +
    ggtitle("Clinton/Trump Polls - Presidential Election Poll Results From 12/2015 - 11/2016") +
      xlab("Time") +
      ylab("Percentage")   
```

## Clinton Time Series Model (ARIMA)

Here I try to fit an ARIMA in the time series data of Clinton's pools. In order to do that I use "auto.arima", which will calculate several models to verify the best fit. The algorithm will do:

```{r}
fit_clinton <- auto.arima(as.vector(Clinton_Trump_Polls[,"Clinton_Polls"]))
fit_clinton
```

Therefore, the best fit is an ARIMA(1,1,2). The algorithm calculate the first difference since the time series was not stationary.

### Forecasting
```{r}
fit_clinton <- auto.arima(as.vector(Clinton_Trump_Polls[,"Clinton_Polls"]))
fit_clinton %>% forecast(h=10) %>% autoplot(include=80)
```
The forecast is good, but not that useful. For a significance level of 5%, the forecast ranges from low 50%'s to 30%'s.

(Saving the plot as pdf/png)
```{r}
pdf(paste(MyPath,"/Clinton_forecast.pdf", sep=""), width = 10, height = 7)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    fit_clinton %>% forecast(h=10) %>% autoplot(include=80)

png(paste(MyPath,"/Clinton_forecast.png", sep=""), width = 800, height = 500)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    fit_clinton %>% forecast(h=10) %>% autoplot(include=80)   
```

### Checking Residuals
```{r}
# autoplot(fit_clinton) # To check if the roots are inside the unit circle
checkresiduals(fit_clinton)
```
Checking the results we see that the model is good to explain past performance. The residuals are almost normally distributed. The ACF does not show any significant lag up to 5 lags.

(Saving the plot as pdf/png)
```{r}
pdf(paste(MyPath,"/Clinton_forecast_residuals.pdf", sep=""), width = 10, height = 8)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    checkresiduals(fit_clinton)

png(paste(MyPath,"/Clinton_forecast_residuals.png", sep=""), width = 800, height = 600)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    checkresiduals(fit_clinton)    
```

## Trump Time Series Model (ARIMA)

Now I try to fit an ARIMA in the time series data of Trump's pools. In order to do that I use "auto.arima", which will calculate several models to verify the best fit. The algorithm will do:

```{r}
fit_trump <- auto.arima(as.vector(Clinton_Trump_Polls[,"Trump_Polls"]))
fit_trump
```
Therefore, the best fit is an ARIMA(1,1,1). The algorithm calculate the first difference since the time series was not stationary.

### Forecasting

```{r}
fit_trump %>% forecast(h=10) %>% autoplot(include=80)
```

The forecast is good, but not that useful. For a significance level of 5%, the forecast ranges from low 50%'s to 30%'s (similar to Clinton).

(Saving the plot as pdf/png)
```{r}
pdf(paste(MyPath,"/Trump_forecast.pdf", sep=""), width = 10, height = 7)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    fit_trump %>% forecast(h=10) %>% autoplot(include=80)

png(paste(MyPath,"/Trump_forecast.png", sep=""), width = 800, height = 500)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    fit_trump %>% forecast(h=10) %>% autoplot(include=80)   
```

### Checking Residuals

```{r}
# autoplot(fit_trump) # To check if the roots are inside the unit circle
checkresiduals(fit_trump)
```

Again, when we checking the results we see that the model is good to explain past performance. The residuals are almost normally distributed. The ACF does not show any significant lag up to 5 lags.

(Saving the plot as pdf/png)
```{r}
pdf(paste(MyPath,"/Trump_forecast_residuals.pdf", sep=""), width = 10, height = 8)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    checkresiduals(fit_trump)

png(paste(MyPath,"/Trump_forecast_residuals.png", sep=""), width = 800, height = 600)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    checkresiduals(fit_trump)  
```


# Markov Models

In this section I run Markov models. The idea is to see how Markov Chains perform predicting the outcome of presidential election per state. In order to do that, we need to load a different dataset. Below I load the results per state (for all 50 states + D.C.) of the election starting on 1900.

## Loading Data & Data Wrangling 

```{r}
us_presid_results_1828_2016 <- fread("C:\\Users\\Caio Laptop\\OneDrive - The University of Kansas\\Documents\\PhD\\11. Courses\\19. EECS 731 - Introduction to Data Science\\Final Project\\US Presidential Results & PVIs by State 1828-2016_edited.csv",
                                      stringsAsFactors = T)
us_presid_results_1828_2016<-us_presid_results_1828_2016[,-(4:6)]
# us_presid_results_1828_2016<-us_presid_results_1828_2016[!(us_presid_results_1828_2016$State=="Nationwide")]

us_presid_results_1828_2016_by_state <- us_presid_results_1828_2016 %>% group_by(State)
us_presid_results_1828_2016_by_state2 <- split(us_presid_results_1828_2016, us_presid_results_1828_2016$State)
```

Creating variables to store elections years, states names, and verifying my first year of elections
```{r}
myStates<-names(us_presid_results_1828_2016_by_state2)
myYears<-unique(us_presid_results_1828_2016$Year)

myStates
myYears
```

Creating a different data.frame for each state with presidential elections results
```{r}
for (i in 1:length(us_presid_results_1828_2016_by_state2)){
  my_state<-as.data.frame(us_presid_results_1828_2016_by_state2[i] , stringsAsFactors = T)[,-3]
  colnames(my_state)<-c("Winner","Year")
  assign(names(us_presid_results_1828_2016_by_state2[i]), my_state)
}
rm(i, my_state)
```

## Markov Chain

Below I run the Markov Chain models. In order to do that I needed to create new data.frames (Errors_matrix, Predictions_2020, and errors_states). So, in this loop, we need to start forecating from the 3rd election in our sample, i.e., election of 1912. The reason is because, to start the chain with reasonably data, we need to 2 election (1900 and 1904) to estimate a transiction matrix. Then, using the result from 1908 election we can predict the outcome for 1912 presidential election per U.S. state. I decided to print the prediction per state per election year (sorry, the output is long - but it helps me to verify the results). Now, to not create to many graphs, for 2020 presidential election I made my loop create a pdf file in which it plots for each state the transiction matrix using diagrams. Finally, I also created a prediction matrix per state for the 2020 election.

```{r}
library(markovchain)

Errors_matrix<-matrix(NA, nrow = (length(myYears)-2), ncol= 2)
Predictions_2020<-NULL
errors_states<-NULL

for (j in 2:(length(myYears)-1)){
  
  if(j==(length(myYears)-1)){
    pdf(paste(MyPath,"/Markov",min(myYears)+4*(j+1),".pdf", sep=""), width=15, height=40)
    par(mfrow=c(13,4))
    par(mar=c(5,5,5,5))
  }  
  
  error=0
  for(i in 1:length(us_presid_results_1828_2016_by_state2)){
    mysequence<-subset(get(myStates[i]), Year<=min(myYears)+4*(j-1))[,1]
    cons_matrix<-createSequenceMatrix(mysequence, possibleStates = c("dem", "rep"))
    myFit<-markovchainFit(data=mysequence,confidencelevel = .9, possibleStates = c("dem", "rep"))
    Realized<-as.character(subset(get(myStates[i]), Year==min(myYears)+4*j)[1],stringsAsFactors =F)
    if(Realized==1){Realized=c("dem")}
    if(Realized==2){Realized=c("rep")}
    myPrediction<-predict(myFit$estimate, newdata=Realized, n.ahead =1)
    print(paste("prediction for state: ", myStates[i], " | Year = ", min(myYears)+4*(j+1), " is ", myPrediction, sep="")) 
    
    if(j==(length(myYears)-1)){
      Predictions<-c(myStates[i], myPrediction)
      Predictions_2020<-rbind(Predictions_2020, Predictions)
    }else{
      Realized_t1<-subset(get(myStates[i]), Year==(min(myYears)+4*(j+1)))[1]
      if(Realized_t1==1){Realized_t1=c("dem")}
      if(Realized_t1==2){Realized_t1=c("rep")}
      
      if(myPrediction==Realized_t1){
        error=error
      }else{ 
        error=error+1 
        errors_states<-rbind(errors_states, myStates[i])
        }
    }
    
    if(j==(length(myYears)-1)){  
      test<-as.matrix(myFit$estimate@transitionMatrix)
      dtmcA <- new("markovchain",transitionMatrix=test, states=c("dem","rep"), name="MarkovChain A")
      plot(dtmcA, cex=1, label.cex=5, label.font= 2, size=4, size2=4, arrow.size=1, #cex.axis=1.5, cex.main=1.5, cex.sub=1.5,
           main=paste("Markov chain plot - Transition Matrix - ", myStates[i], sep=""),
           edge.arrow.size=1)
    }  
  }
  
  if (j<(length(myYears)-1)){
  Errors_matrix[j,1] <- (min(myYears)+4*(j+1))
  Errors_matrix[j,2] <- error
  }else{dev.off()}
}
```

## Cleaning NAs and defining my data.frame for the number of errors
```{r}
Errors_matrix<-Errors_matrix[-(1:2),]
colnames(Errors_matrix) <- c("Year", "Number_Errors")
Errors_matrix<-as.data.frame(Errors_matrix)
```

## Plot the number of Errors per Election from 1916 to 2016
```{r}
ggplot(data=Errors_matrix, aes(Year)) +
  geom_smooth(aes(y=Number_Errors, color = "red") ,show.legend = FALSE)
```

(Saving the plot as pdf/png)
```{r}
pdf(paste(MyPath,"/Number_Errors_Over_Time_Markov.pdf", sep=""), width = 10, height = 7)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(data=Errors_matrix, aes(Year)) +
      geom_smooth(aes(y=Number_Errors, color = "red") ,show.legend = FALSE)

png(paste(MyPath,"/Number_Errors_Over_Time_Markov.png", sep=""), width = 800, height = 500)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(data=Errors_matrix, aes(Year)) +
      geom_smooth(aes(y=Number_Errors, color = "red") ,show.legend = FALSE)
```


## Defining my data.frame of number of errors per state 
```{r}
errors_states<-as.data.frame(errors_states)  
colnames(errors_states) <- c("State")
```


## Plot Number of Errors per State (1 - Flipped w/ legend)
```{r}
ggplot(errors_states) +
  stat_count(mapping = aes(x = State, fill = State)) +
  coord_flip() +
  theme(legend.position = "top")
```

(Saving the plot as pdf/png)
```{r}
pdf(paste(MyPath,"/Markov_Errors_per_State_1.pdf", sep=""), width=10, height=7)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(errors_states) +
      stat_count(mapping = aes(x = State, fill = State)) +
      coord_flip() +
      theme(legend.position = "top")
    dev.off()
    
png(paste(MyPath,"/Markov_Errors_per_State_1.png", sep=""), width=800, height=500)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(errors_states) +
      stat_count(mapping = aes(x = State, fill = State)) +
      coord_flip() +
      theme(legend.position = "top")
    dev.off()
```

## Plot Number of Errors per State (2 - Flipped without legend)
```{r}
ggplot(errors_states) +
  stat_count(mapping = aes(x = State, fill = State)) +
  coord_flip()
```

(Saving the plot as pdf/png)
```{r}
pdf(paste(MyPath,"/Markov_Errors_per_State_2.pdf", sep=""), width=10, height=7)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(errors_states) +
      stat_count(mapping = aes(x = State, fill = State)) +
      coord_flip()
    dev.off()
    
png(paste(MyPath,"/Markov_Errors_per_State_2.png", sep=""), width=800, height=500)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(errors_states) +
      stat_count(mapping = aes(x = State, fill = State)) +
      coord_flip()
    dev.off()
```



# Plot Number of Errors per State (3 - Flipped with legend)
```{r}
ggplot(errors_states) +
  stat_count(mapping = aes(x = State, fill = State)) +
  theme(legend.position = "top")
```

(Saving the plot as pdf/png)
```{r}
pdf(paste(MyPath,"/Markov_Errors_per_State_3.pdf", sep=""), width=7, height=10)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(errors_states) +
      stat_count(mapping = aes(x = State, fill = State)) +
      theme(legend.position = "top")
    dev.off()
    
png(paste(MyPath,"/Markov_Errors_per_State_3.png", sep=""), width=500, height=800)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(errors_states) +
      stat_count(mapping = aes(x = State, fill = State)) +
      theme(legend.position = "top")
    dev.off()
```


# Plot Number of Errors per State (4 - Flipped without legend)
```{r}
ggplot(errors_states) +
  stat_count(mapping = aes(x = State, fill = State))
```

(Saving the plot as pdf/png)
```{r}
pdf(paste(MyPath,"/Markov_Errors_per_State_4.pdf", sep=""), width=7, height=10)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(errors_states) +
      stat_count(mapping = aes(x = State, fill = State))
    dev.off()
    
png(paste(MyPath,"/Markov_Errors_per_State_4.png", sep=""), width=500, height=800)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(errors_states) +
      stat_count(mapping = aes(x = State, fill = State))
    dev.off()
```
  
## 2020 Presidential Election Prediction

Some data wrangling in my "Predictions_2020" variable from my Markov model
```{r}
Predictions_2020 <- apply(Predictions_2020,2,tolower)
Predictions_2020 <-as.data.frame(Predictions_2020, stringsAsFactors = TRUE)
colnames(Predictions_2020) <-c("State", "Pred_winner")
Predictions_2020_by_party <- split(Predictions_2020, Predictions_2020$Pred_winner)
```

Defining variables for which states are predicted as democratic or republican
```{r}
all_states <- map_data("state") 
states_democratic  <-as.vector(Predictions_2020_by_party$dem[,1])
states_republican  <- as.vector(Predictions_2020_by_party$rep[,1])
```


### Creating a US map with the 2020 Presidential Election using Markov Chain

```{r}
ggplot(all_states, aes(x=long, y=lat, group = group)) +
  geom_polygon(fill="grey", colour = "white") +
  geom_polygon(fill="blue", data = filter(all_states, region %in% states_democratic), color = "white") +
  geom_polygon(fill="red", data = filter(all_states, region %in% states_republican), color = "white") +
  labs(title = "2020 Presidential Election using Markov Chain")
```

(Saving the plot as pdf/png)
```{r}
pdf(paste(MyPath,"/2020_Presidential_Election_Prediction.pdf", sep=""), width=10, height=7)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(all_states, aes(x=long, y=lat, group = group)) +
      geom_polygon(fill="grey", colour = "white") +
      geom_polygon(fill="blue", data = filter(all_states, region %in% states_democratic), color = "white") +
      geom_polygon(fill="red", data = filter(all_states, region %in% states_republican), color = "white") +
      labs(title = "2020 Presidential Election using Markov Chain")
      
png(paste(MyPath,"/2020_Presidential_Election_Prediction.png", sep=""), width=800, height=500)
    par(mfrow=c(1,1))
    par(mar=c(5,5,5,5))
    ggplot(all_states, aes(x=long, y=lat, group = group)) +
      geom_polygon(fill="grey", colour = "white") +
      geom_polygon(fill="blue", data = filter(all_states, region %in% states_democratic), color = "white") +
      geom_polygon(fill="red", data = filter(all_states, region %in% states_republican), color = "white") +
      labs(title = "2020 Presidential Election using Markov Chain")
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
